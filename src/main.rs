mod config;
mod storage;

use clap::{Parser, Subcommand};
use config::Config;
use std::path::PathBuf;
use std::str::FromStr;
use tracing::{debug, info};
use tracing_subscriber::{
    self, filter::LevelFilter, fmt, layer::SubscriberExt, reload, util::SubscriberInitExt,
};

// Include the built information generated by build.rs
mod built_info {
    include!(concat!(env!("OUT_DIR"), "/built.rs"));
}

fn get_version() -> String {
    #[cfg(debug_assertions)]
    {
        // For debug builds, use git commit ID from build-time information
        if let Some(commit_version) = built_info::GIT_VERSION {
            format!("Development build (commit: {commit_version})")
        } else if let Some(commit_short) = built_info::GIT_COMMIT_HASH_SHORT {
            format!("Development build (short commit: {commit_short})")
        } else {
            "Development build (unknown commit)".to_string()
        }
    }

    #[cfg(not(debug_assertions))]
    {
        // For release builds, use the package version
        format!("Version {}", built_info::PKG_VERSION)
    }
}

#[derive(Parser)]
#[command(name = "RNAS", arg_required_else_help = true)]
#[command(about = "A unified solution for your Network Attached Storage systems", long_about = None)]
struct Cli {
    #[arg(
        short,
        long,
        value_name = "FILE",
        help = "Path to the configuration file"
    )]
    config: Option<PathBuf>,

    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    /// Display version information
    Version,

    /// Test command
    Test,
}

fn main() {
    let cli = Cli::parse();
    if let Some(Commands::Version) = cli.command {
        println!("{}", get_version());
        return;
    }

    let Some(config_path) = cli.config else {
        eprintln!("No configuration file specified. Use -c/--config to specify a path.",);
        std::process::exit(1);
    };
    if !config_path.exists() {
        eprintln!("Configuration file not found at: {}", config_path.display(),);
        std::process::exit(1);
    }
    let configs = Config::from_file(&config_path);
    let Ok(configs) = configs else {
        eprintln!(
            "Failed to load config file at {}, error in file occurs: {}",
            config_path.display(),
            configs.err().unwrap(),
        );
        // write default config
        // Config::default().save_to_file("./config.toml");
        std::process::exit(1);
    };

    // init tracing
    let default_level_filter = LevelFilter::from_str(configs.common.log_level.as_str())
        .unwrap_or_else(|e| {
            eprintln!(
                "Invalid log level '{}': {}, using INFO for now",
                configs.common.log_level, e
            );
            LevelFilter::INFO
        });
    let (filter, reload_handle) = reload::Layer::new(default_level_filter);

    tracing_subscriber::registry()
        .with(filter)
        .with(fmt::Layer::default())
        .init();

    debug!(?config_path, ?configs, "Configuration successfully loaded");
    match cli.command {
        Some(Commands::Test) => {
            info!("Running test command...");
        }
        None => {}
        _ => {}
    }
}
